---
title: "Working with Paths"
author: "Hauke Sonnenberg"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with Paths}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

In our FAKIN project we want to improve the (research) data management at KWB. 
We realised that we have difficulties in finding files. One reason is that our 
folder structures differ between the projects and they are often not intuitive 
at all.

This package contains functions that help analysing folder structures.

## Providing File Path Information

Assume we have a vector of file paths. It may have been read from a file that
was created by redirecting the output of the `dir` command in the Windows 
Command Window to a file (`dir /s /b > paths.txt`).

```{r}
paths <- c(
  "project-1/wp-1/input/file 1.csv",
  "project-1/wp-1/input/file-2.csv",
  "project-1/wp-1/analysis/summary.pdf",
  "project-1/wp 2/input/köpenick_dirty.csv",
  "project-1/wp 2/output/koepenick_clean.csv",
  "project-2/Daten/file-1.csv",
  "project-2/Grafiken/file 1.png",
  "project-2/Berichte/bericht-1.doc",
  "project-2/Berichte/bericht-2.doc"
)
```

## Plotting Paths

Let's get a first impression on the paths defined above by plotting them. We 
provide a plot function that uses the `sankeyNetwork()` function from the 
networkD3 package. Make sure that this package is installed:

```{r}
if (! require("networkD3")) {
  
  install.packages("networkD3", repos = "https://cloud.r-project.org")
}
```

You can then use the `plot_path_network()` function from the kwb.fakin package
to plot the example paths defined above:

```{r}
kwb.fakin::plot_path_network(paths)
```

The function accepts all arguments provided by `networkD3::sankeyNetwork()`.
You may e.g. use the argument `fontSize` to increase the node labels:

```{r}
kwb.fakin::plot_path_network(paths, fontSize = 16)
```

Let's always use this font size by defining a short helper function:

```{r}
plot_16pt <- function(...) kwb.fakin::plot_path_network(..., fontSize = 16)
```

By default only the first three levels of folders or files are shown. You can
increase (or decrease) the number of shown levels by setting the `max_depth` argument:

```{r}
plot_16pt(paths, max_depth = 4)
```

Now, that all three traffic light colours (green, yellow, red) appear in the 
plot, we want to explain what these colours are intended to indicate:

* Green: name is fully compliant with our naming rules. It consists only of
alphanumeric letters, underscore, hyphen or dot. 

* Yellow: name is almost compliant with our naming rules. It constists only of 
alphanumeric letters, underscore, hyphen, dot or space. 

* Red: name does not comply with our naming rules. It contains at least one
character that is not alphanumeric or underscore, hyphen, dot or space. In most
of our cases this is due to German special characters, such as 'ä', 'ö', 'ü'.

The naming rules are documented in our 
[FAKIN Best Practices Document](https://kwb-r.github.io/fakin.doc/best-practices.html#data-storage-naming)

## Selecting Paths

If you want to investigate a complex folder structure with 
hundreds or thousands of files the overview plot will not show up properly.
It is then useful to select only a subsection of the folder structure for 
further investigation. To simplify the selection of paths we wrote a function 
that converts a vector of path strings into a nested list. In that list, the
folder names appear as the names of the list elements. Let's try this out with
the example paths defined above:

```{r}
# Convert the vector of paths into a tree structure
path_tree <- kwb.fakin:::to_tree(paths)

# Show the structure of the tree
str(path_tree)
```
The path tree is a list of lists with the top level elements representing the
top level folders of the paths, the second level elements representing the
sub-folders of the top level folders, and so on. With that tree structure, it is
easy to select a sub-tree by just using the dollar operator `$` for lists. If, 
for example, we want to select the paths belonging to project 1, we can write:

```{r}
# Select the sub-tree below "project-1"
subtree <- path_tree$`project-1`

# Show the sub-tree
str(subtree)
```
**Note** that the element name `project-1` needs to be quoted in special quotes
because, in R, the hyphen would else be interpreted as minus operator. 

To convert the tree structure back to the path strings, use `flatten_tree`:

```{r}
kwb.fakin:::flatten_tree(subtree)
```

You can plot the sub-tree by passing it directly to `plot_path_network`, or here
to our helper function, without prior conversion:

```{r}
plot_16pt(subtree)
```

## Quality of File and Folder Names

The automatic processing of files may fail due to special characters (e.g. 
German Umlaute) that are contained in the folder or file names. The package 
contains a function `ascii_stats` that calculates the percentages of strings 
containing or not containing special (non-ASCII) characters. 

```{r}
kwb.fakin:::ascii_stats(paths)
```

The aim should be to reduce the percentage of non-ASCI characters.

## Quality of Folder Structures

If we modify folder structures in order to make them more intuitive we need a
tool to measure the improvement. Therefore I created an account on the 
following website:

https://www.optimalworkshop.com/treejack

There, you can define tree structures of which interactive web-pages are created
where users are asked to navigate to a certain file in the tree. Behind the
scenes the web page tracks the clicks of the user on his way through the tree. 
The treejack service provides an import functionality where you can define
the structure of the tree by giving a set of text lines with each line 
representing a branch or a leaf of the tree.

The function `subtree_for_treejack` creates the text that is required here:

```{r}
kwb.fakin:::subtree_for_treejack(root = "project-1", paths)
```

## Analysis of Paths

We can split the paths into their parts using `splitPaths`:

```{r}
parts <- kwb.fakin:::splitPaths(paths)
parts[1:3]
```

It may be useful to convert the list that is returned by `splitPaths` into a
matrix:

```{r}
subdirs <- kwb.fakin:::toSubdirMatrix(parts)
```

```{r results = "asis", echo = FALSE}
knitr::kable(subdirs, caption = "Content of the subdirs matrix")
```

In the matrix, each row represents a path and each column represents a depth 
level.

If you have only one path, you may create the paths to all direct parent
directories using the function `all_path_levels`. This is how 
`subtree_for_treejack` creates the text for the bulk import to Treejack (see 
above).

```{r}
(parent_paths <- kwb.fakin:::all_path_levels(paths[1]))

parents <- kwb.fakin:::toSubdirMatrix(parent_paths)
```

```{r results = "asis", echo = FALSE}
knitr::kable(parents, caption = "Content of the parents matrix")
```

## Importance of Directories

In order to find the most important folder paths in terms of frequency and
length you may use the function `sortedImportance`:

```{r}
kwb.fakin:::sortedImportance(dirname(paths))
```

## Compression of Folder Paths

Assume you have a folder with a long path (either due to a lot of levels or due
to long folder names). This long path is repeated for each file in the folder. 
The package provides a `compress` function that may be used to introduce short 
names for directory paths.

```{r}
directories <- c("short", "short", "short", "longer/path", "longer/path")

short_dirs <- kwb.fakin:::compress(directories)

as.character(short_dirs)
```

The function returns the lookup table (dictionary) that maps short names to long 
names in the attribute `dict`:

```{r collapse = TRUE}
(dictionary <- kwb.utils::getAttribute(short_dirs, "dict"))
```

The dictionary is sorted by the importance of the strings (paths) that have been
given to `compress` so that the most important paths get the highest positions 
in the dictionary. With importance we mean the product of the length of a string 
(path) and its number of occurrences.

The dictionary is required to convert the short names back to the original
paths using the `resolve` function of the `kwb.utils` package:

```{r collapse = TRUE}
(long_dirs <- kwb.utils::resolve(short_dirs, dictionary))

identical(long_dirs, directories)
```

There is another function `compressOneByOne`, what does it do?

```{r}
attributes(kwb.fakin:::compressOneByOne(paths, n = 3))
```

